---
title: Kiểu Nguyên thủy và  kiểu Tham chiếu
description: Tìm hiểu về các kiểu dữ liệu Nguyên thủy và Tham chiếu trong JavaScript.
slug: primitive-and-reference-types
language: vi
date: 2024-09-06 10:00
cover: /images/posts/cover.jpg
excerpt: In JavaScript, primitive types include:\ string, number, bigint, boolean, symbol, null, and undefined. These are data types whose values contain a single simple value and are not objects.
authors:
  - ngockhoi96
---

## Primitive types

<Image
  src="/images/articles/primitive-and-reference-types/image-01.png"
  alt="Image test unsplash"
  sizes="100vw"
  width={0}
  height={0}
  style={{ width: '100%', height: 'auto' }}
/>

### Primitive types là gì?

Trong JavaScript, các kiểu dữ liệu nguyên thủy (_==primitive types==_) bao gồm: `string`, `number`, `bigint`, `boolean`, `symbol`, `null` và `undefined`. Đây là những kiểu dữ liệu mà giá trị của chúng chỉ chứa một giá trị đơn giản và không phải là một đối tượng.

**Cú pháp sử dụng**: không cần cú pháp đặc biệt, chỉ cần gán giá trị cho biến.

Thí dụ:

```js
const name = 'Grizz'; // string
const age = 27; // number
const isHuman = false; // boolean
const car = null; // null
const job = undefined; // undefined
const bigNumber = 9007199254740991n; // bigint
const symbol = Symbol('symbol'); // symbol
```

### Cách Primitive types được lưu trữ

Các giá trị nguyên thủy được lưu trực tiếp tại vị trí bộ nhớ mà biến chỉ đến, không giống như _==reference types==_ (chỉ lưu địa chỉ tham chiếu đến nơi chứa dữ liệu thực tế).

Thí dụ: Khi khai báo một biến kiểu nguyên thủy.

```js
let myName = 'ngockhoi96';
let myAge = 24;
```

Giá trị `"ngockhoi96"` và `24` được lưu trực tiếp tại vị trí bộ nhớ của biến `myName` và `myAge`.

<Image
  src="/images/articles/primitive-and-reference-types/image-02.png"
  alt="Image test unsplash"
  sizes="100vw"
  width={0}
  height={0}
  style={{ width: '100%', height: 'auto' }}
/>

Tiếp theo, sửa giá trị của biến `myName` thành `"khoikhukho"`:

```js
myName = 'khoikhukho';
```

<Image
  src="/images/articles/primitive-and-reference-types/image-03.png"
  alt="Image test unsplash"
  sizes="100vw"
  width={0}
  height={0}
  style={{ width: '100%', height: 'auto' }}
/>

Biến `myName` được sửa thành `"khoikhukho"` và giá trị `"khoikhukho"` được thay thế trực tiếp vào vị trí bộ nhớ của biến.

Tiếp tục tạo ra biến `myNameCopy` và gán giá trị của `myName` cho `myNameCopy`:

```js
let myNameCopy = myName;
```

<Image
  src="/images/articles/primitive-and-reference-types/image-04.png"
  alt="Image test unsplash"
  sizes="100vw"
  width={0}
  height={0}
  style={{ width: '100%', height: 'auto' }}
/>

Sửa giá trị của `myName` thành `"khoikhukho96"`:

```js
myName = 'khoikhukho96';
```

<Image
  src="/images/articles/primitive-and-reference-types/image-05.png"
  alt="Image test unsplash"
  sizes="100vw"
  width={0}
  height={0}
  style={{ width: '100%', height: 'auto' }}
/>

Kết quả, biến `myNameCopy` lưu trữ giá trị `"khoikhukho96"` và biến `myName` vẫn lưu trữ giá trị `"khoikhukho"`:

Các giá trị nguyên thủy được lưu trực tiếp tại vị trí bộ nhớ mà biến chỉ đến, nên việc sửa biến copy sẽ chỉ thay đổi giá trị của biến copy mà không ảnh hưởng đến biến ban đầu.

### Ưu điểm khi sử dụng Primitive types

- **Hiệu suất cao hơn**: Vì giá trị được lưu trực tiếp trong vị trí bộ nhớ của biến, việc truy cập và xử lý dữ liệu nhanh chóng.
- **So sánh giá trị dễ dàng**: Khi so sánh 2 giá trị nguyên thủy, JavaScript sẽ so sánh giá trị thực tế của chúng, đảm bảo tính chính xác.

Thí dụ: Dễ dàng so sánh 2 giá trị nguyên thủy.

```js
const herScore = 10;
const hisScore = 10;

console.log(herScore === hisScore); // true
```

### Primitive types là bất biến

Trong JavaScript, các giá trị nguyên thủy là bất biến ([_immutable_](https://developer.mozilla.org/en-US/docs/Glossary/Immutable)). Điều này có nghĩa là một khi một giá trị nguyên thủy được tạo, giá trị đó không thể thay đổi.

Thí dụ: Không thể sửa được một chuỗi

```js
let greeting = 'Hello';
greeting[1] = 'i';

console.log(greeting); // Hello
```

Sự bất biến của giá trị nguyên thủy giúp đảm bảo tính toàn vẹn của dữ liệu và giúp chúng ta dễ dàng kiểm soát các thay đổi dữ liệu trong chương trình.

---

## Reference types

<Image
  src="/images/articles/primitive-and-reference-types/image-06.png"
  alt="Image test unsplash"
  sizes="100vw"
  width={0}
  height={0}
  style={{ width: '100%', height: 'auto' }}
/>

### Reference types là gì?

Kiểu tham chiếu (_==Reference types==_) trong JavaScript bao gồm các kiểu dữ liệu như `object`, `array`, `function`, và các đối tượng khác. Khác với kiểu dữ liệu nguyên thủy, kiểu tham chiếu lưu trữ địa chỉ (_tham chiếu_) của giá trị trong bộ nhớ, thay vì giá trị thực tế.

Thí dụ:

```js
const bear = { name: 'Grizz', age: 8, isHungry: true };
const favoriteFoods = ['pizza', 'honey', 'sandwich'];

function sum(a, b) {
  return a + b;
}
```

Biến `bear`, `favoriteFoods` và `sum` thực chất chỉ lưu trữ địa chỉ tham chiếu tới giá trị trong bộ nhớ _==Heap==_, chứ không trực tiếp lưu trữ chúng.

<Image
  src="/images/articles/primitive-and-reference-types/image-07.png"
  alt="Image test unsplash"
  sizes="100vw"
  width={0}
  height={0}
  style={{ width: '100%', height: 'auto' }}
/>

### Cách Reference types được lưu trữ

Thí dụ: Tạo object `bear`.

```js
let bear = { name: 'Grizz' };
```

<Image
  src="/images/articles/primitive-and-reference-types/image-08.png"
  alt="Image test unsplash"
  sizes="100vw"
  width={0}
  height={0}
  style={{ width: '100%', height: 'auto' }}
/>

Tạo biến `bearCopy` từ `bear`.

```js
let bearCopy = bear;
```

<Image
  src="/images/articles/primitive-and-reference-types/image-09.png"
  alt="Image test unsplash"
  sizes="100vw"
  width={0}
  height={0}
  style={{ width: '100%', height: 'auto' }}
/>

Lúc này, cả `bear` và `bearCopy` đều tham chiếu đến cùng một object trong bộ nhớ _==Heap==_, nên sửa một biến sẽ thấy sự thay đổi thông qua biến còn lại.

Thí dụ:

```js
let bear = { name: 'Grizz' };
let bearCopy = bear;

bearCopy.name = 'Panda';

console.log(bearCopy.name); // Panda
console.log(bear.name); // Panda
```

<Image
  src="/images/articles/primitive-and-reference-types/image-10.png"
  alt="Image test unsplash"
  sizes="100vw"
  width={0}
  height={0}
  style={{ width: '100%', height: 'auto' }}
/>

Đó chính là lý do tại sao chúng ta cần sử dụng phương thức `Object.assign()` hoặc toán tử `spread` để copy thuộc tính sang một object mới.

Thí dụ:

```js
let bear = { name: 'Ice bear' };
let bearCopy = Object.assign({}, bear);

console.log(bearCopy.name); // Ice bear
console.log(bear.name); // Ice bear
```

<Image
  src="/images/articles/primitive-and-reference-types/image-11.png"
  alt="Image test unsplash"
  sizes="100vw"
  width={0}
  height={0}
  style={{ width: '100%', height: 'auto' }}
/>

### Ưu điểm khi sử dụng Reference types

- **Lưu trữ và quản lý cấu trúc dữ liệu phức tạp**: Cho phép tạo ra các cấu trúc dữ liệu như đối tượng và mảng để lưu trữ và quản lý thông tin một cách có tổ chức.
- **Thao tác linh hoạt**: Cung cấp khả năng thao tác dữ liệu thông qua các phương thức và thuộc tính, hỗ trợ lập trình hướng đối tượng.

Thí dụ: Thay đổi giá trị của thuộc tính trong đối tượng.

```js
const myCar = { brand: 'BMW', year: 2020, color: 'gray' };
myCar.color = 'black';

console.log(myCar.color); // black
```

---

## So sánh giữa Primitive và Reference types

### So sánh chi tiết

**Khi lưu trữ dữ liệu**:

- **Primitive types**: Lưu giá trị trực tiếp trong vị trí bộ nhớ mà biến đề cập đến. Khi bạn gán giá trị của một biến nguyên thủy cho biến khác, một bản sao của giá trị đó được tạo và lưu trữ một cách độc lập.
- **Reference types**: Lưu địa chỉ (tham chiếu) đến vị trí bộ nhớ nơi dữ liệu thực sự được lưu. Khi gán giá trị của một biến tham chiếu cho biến khác, cả hai biến đều tham chiếu đến cùng một địa chỉ bộ nhớ.

**Khi so sánh**:

- **Primitive types**: So sánh giá trị thực tế của chúng. Nếu giá trị giống nhau, kết quả trả về `true`.
- **Reference types**: So sánh địa chỉ bộ nhớ mà chúng tham chiếu. Nếu cả hai tham chiếu đến cùng một địa chỉ, kết quả trả về `true`.

**Về hiệu năng**:

- **Primitive types**: Hiệu suất truy cập dữ liệu nhanh hơn hơn vì giá trị được lưu trực tiếp trong vị trí bộ nhớ.
- **Reference types**: Hiệu suất truy cập dữ liệu chậm hơn vì cần truy cập đến địa chỉ tham chiếu trước khi truy cập dữ liệu thực sự.

**Trường hợp sử dụng**:

- **Primitive types**: Thích hợp cho việc lưu trữ và xử lý thông tin đơn giản, như tên người dùng, điểm số, v.v.
- **Reference types**: Thích hợp cho việc lưu trữ và quản lý thông tin phức tạp, như thông tin người dùng, sản phẩm, hoặc các đối tượng có nhiều thuộc tính và phương thức.

### Bảng so sánh nhanh

| Đặc điểm           | Primitive types             | Reference types                    |
| ------------------ | --------------------------- | ---------------------------------- |
| Lưu trữ dữ liệu    | Trực tiếp tại vị trí bộ nhớ | Địa chỉ tham chiếu tới bộ nhớ      |
| So sánh            | Giá trị thực tế             | Địa chỉ tham chiếu                 |
| Sao chép giá trị   | Tạo bản sao độc lập         | Tham chiếu đến cùng địa chỉ bộ nhớ |
| Hiệu năng          | Cao do truy cập trực tiếp   | Có thể chậm do truy cập gián tiếp  |
| Trường hợp sử dụng | Dữ liệu đơn giản            | Dữ liệu phức tạp                   |

Tóm lại, tùy vào nhu cầu cụ thể của từng tình huống cụ thể mà bạn sẽ chọn sử dụng kiểu dữ liệu nguyên thủy hoặc kiểu tham chiếu sao cho phù hợp.

---

## Các sai lầm thường gặp

### So sánh trực tiếp giữa hai đối tượng

Khi so sánh trực tiếp hai đối tượng, JavaScript sẽ so sánh địa chỉ tham chiếu, không phải giá trị của đối tượng.

**Cách giải quyết**: Sử dụng vòng lặp hoặc phương thức như `JSON.stringify()` để so sánh giá trị bên trong.

Thí dụ:

```js
const motorbike1 = { brand: 'Honda', year: 2020 };
const motorbike2 = { brand: 'Honda', year: 2020 };

console.log(JSON.stringify(motorbike1) === JSON.stringify(motorbike2)); // true
```

### Không hiểu rõ về tính chất tham chiếu

Gán một đối tượng cho một biến khác và sửa đổi giá trị trong một biến có thể không ý thức được rằng nó cũng thay đổi giá trị trong biến khác.

```js fileName="example.js"
let originalBrand = { name: 'BWM' };
let copyBrand = originalBrand;

copyBrand.name = 'Audi';

console.log(copyBrand.name); // Audi
console.log(originalBrand.name); // Audi
```

**Cách giải quyết**: Sử dụng `Object.assign()` để tạo bản sao mới.

Thí dụ:

```js
let originalBrand = { name: 'BWM' };
let copyBrand = Object.assign({}, originalBrand);

copyBrand.name = 'Audi';

console.log(copyBrand.name); // Audi
console.log(originalBrand.name); // BWM
```

<Callout status="warning">
  _Lưu ý cách này chỉ là sao chép nông ([shallow
  copy](https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy)). Nếu có
  object con bên trong thì nó chỉ sao chép tham chiếu, chứ không tạo ra object
  mới cho object con đó._
</Callout>

Thí dụ:

```js
let myCar = {
  brand: 'BMW',
  engine: { type: 'V8' },
};
let carCopy = Object.assign({}, myCar);

console.log(carCopy.engine === myCar.engine); // true
```

<Image
  src="/images/articles/primitive-and-reference-types/image-12.png"
  alt="Image test unsplash"
  sizes="100vw"
  width={0}
  height={0}
  style={{ width: '100%', height: 'auto' }}
/>

<Details title="What is Shallow copy?">
 `next-intl` uses [`cache()`](https://react.dev/reference/react/cache) to create a mutable store that holds the current locale. By calling `unstable_setRequestLocale`, the current locale will be written to the store, making it available to all APIs that require the locale.

Note that the store is scoped to a request and therefore doesn't affect other requests that might be handled in parallel while a given request resolves asynchronously.

</Details>

Cách giải quyết khi cần sao chép sâu ([_deep copy_](https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy))
là sử dụng hàm `structuredClone()` có sẵn trong JavaScript.

Thí dụ:

```js
let myCar = {
  brand: 'BMW',
  engine: { type: 'V8' },
};
let carCopy = structuredClone(myCar);

console.log(carCopy.engine === myCar.engine); // false
```

Hàm `structuredClone()` sẽ nhận vào một object và trả về một object mới, là sao chép sâu ([_deep copy_](https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy)) của object ban đầu.

<Image
  src="/images/articles/primitive-and-reference-types/image-13.png"
  alt="Image test unsplash"
  sizes="100vw"
  width={0}
  height={0}
  style={{ width: '100%', height: 'auto' }}
/>
